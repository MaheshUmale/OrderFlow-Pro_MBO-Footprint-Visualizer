/**
 * UPSTOX BRIDGE SERVER + QUESTDB INGESTION
 * ----------------------------------------
 * 1. Connects to Upstox V3 WebSocket (Protobuf).
 * 2. Relays decoded JSON to Frontend.
 * 3. Automatically initializes QuestDB Schema.
 * 4. Persists live Ticks and Depth to QuestDB.
 * 
 * PREREQUISITES:
 * npm install ws protobufjs upstox-nodejs axios
 */

const WebSocket = require('ws');
const protobuf = require('protobufjs');
const path = require('path');
const https = require('https');
const axios = require('axios'); // Used for QuestDB REST API

// Configuration
const PORT = 4000;
const QUESTDB_URL = 'http://localhost:9000/exec'; // Default QuestDB REST Endpoint

// State
let upstoxSocket = null;
let frontendSocket = null;
let protobufRoot = null;
let currentInstruments = new Set();
let userToken = null;

// Load Protobuf Definition
const PROTO_PATH = path.join(__dirname, '../market_data_feed.proto'); 
let FeedResponse;

console.log("Loading Proto file...");
try {
    protobufRoot = protobuf.loadSync(PROTO_PATH);
    FeedResponse = protobufRoot.lookupType("com.upstox.marketdatafeeder.rpc.proto.FeedResponse");
} catch (e) {
    try {
        protobufRoot = protobuf.loadSync("market_data_feed.proto");
        FeedResponse = protobufRoot.lookupType("com.upstox.marketdatafeeder.rpc.proto.FeedResponse");
    } catch (e2) {
        console.error("CRITICAL: Could not load 'market_data_feed.proto'.");
        process.exit(1);
    }
}

// =============================================================================
// QUESTDB LOGIC
// =============================================================================

async function initQuestDB() {
    console.log("Initializing QuestDB Schema...");
    
    // 1. Table: market_ticks (High frequency L1 data)
    const createTicks = `
        CREATE TABLE IF NOT EXISTS market_ticks (
            instrument_key SYMBOL,
            price DOUBLE,
            volume DOUBLE,
            oi DOUBLE,
            timestamp TIMESTAMP
        ) TIMESTAMP(timestamp) PARTITION BY DAY WAL;
    `;

    // 2. Table: market_depth (Snapshot of top bid/ask)
    const createDepth = `
        CREATE TABLE IF NOT EXISTS market_depth (
            instrument_key SYMBOL,
            bid_price DOUBLE,
            bid_qty DOUBLE,
            ask_price DOUBLE,
            ask_qty DOUBLE,
            timestamp TIMESTAMP
        ) TIMESTAMP(timestamp) PARTITION BY DAY WAL;
    `;

    // 3. Table: trade_signals (Generated by the AI engine - placeholder for backend logic)
    const createSignals = `
        CREATE TABLE IF NOT EXISTS trade_signals (
            instrument_key SYMBOL,
            signal_type SYMBOL,
            side SYMBOL,
            price DOUBLE,
            message STRING,
            timestamp TIMESTAMP
        ) TIMESTAMP(timestamp) PARTITION BY MONTH WAL;
    `;

    try {
        await axios.get(QUESTDB_URL, { params: { query: createTicks } });
        await axios.get(QUESTDB_URL, { params: { query: createDepth } });
        await axios.get(QUESTDB_URL, { params: { query: createSignals } });
        console.log("✅ QuestDB Tables Ready (market_ticks, market_depth, trade_signals)");
    } catch (err) {
        console.error("⚠️ QuestDB Connection Failed. Is QuestDB running on port 9000?");
        console.error("   Data will NOT be saved to DB, but Live Feed will still work.");
    }
}

async function saveToQuestDB(feedObject) {
    // Upstox V3 Feed Structure Mapping
    if (!feedObject.feeds) return;

    const queries = [];
    const timestamp = Date.now() * 1000; // Microseconds for QuestDB usually, or ISO string. Let's use system time for ingestion.

    Object.keys(feedObject.feeds).forEach(key => {
        const feed = feedObject.feeds[key];
        
        if (feed.fullFeed && feed.fullFeed.marketFF) {
            const ff = feed.fullFeed.marketFF;
            
            // Extract Tick Data
            if (ff.ltpc) {
                const price = ff.ltpc.ltp;
                const volume = ff.vtt ? parseFloat(ff.vtt) : 0;
                const oi = ff.oi ? parseFloat(ff.oi) : 0;
                
                // QuestDB Influx Line Protocol is faster, but we use REST for simplicity here
                // Format: INSERT INTO table_name VALUES (...)
                // Note: QuestDB SQL INSERT is slower than ILP, but works for basic streaming.
                queries.push(`INSERT INTO market_ticks VALUES ('${key}', ${price}, ${volume}, ${oi}, systimestamp())`);
            }

            // Extract Depth Data (Top Level Only for storage efficiency)
            if (ff.marketLevel && ff.marketLevel.bidAskQuote && ff.marketLevel.bidAskQuote.length > 0) {
                const top = ff.marketLevel.bidAskQuote[0];
                const bidP = top.bidP || 0;
                const bidQ = top.bidQ || 0;
                const askP = top.askP || 0;
                const askQ = top.askQ || 0;

                queries.push(`INSERT INTO market_depth VALUES ('${key}', ${bidP}, ${bidQ}, ${askP}, ${askQ}, systimestamp())`);
            }
        }
    });

    if (queries.length > 0) {
        try {
            // Batch insert is better, but strictly speaking via REST /exec, we usually send one by one or use ILP.
            // For this bridge, we fire and forget to avoid blocking the loop.
            // We join with semicolon? No, QuestDB REST doesn't always support multi-statement easily without specific settings.
            // We will just execute the first one or iterate. 
            // *Optimization*: For high freq, use ILP. Here we just pick the first tick to demonstrate integration.
            
            // Simple loop to insert (Production: replace with Influx Line Protocol over TCP)
            for (const q of queries) {
                 axios.get(QUESTDB_URL, { params: { query: q } }).catch(() => {});
            }
        } catch (e) {
            // Ignore insert errors to keep stream alive
        }
    }
}

// =============================================================================
// SERVER SETUP
// =============================================================================

// Start Local WebSocket Server for Frontend
const wss = new WebSocket.Server({ port: PORT });
console.log(`Bridge Server running on ws://localhost:${PORT}`);

// Initialize DB immediately on start
initQuestDB();

wss.on('connection', (ws) => {
    console.log("Frontend connected to Bridge");
    frontendSocket = ws;

    ws.on('message', async (message) => {
        try {
            const msg = JSON.parse(message);
            
            if (msg.type === 'init') {
                console.log("Received Init from Frontend");
                userToken = msg.token;
                if (msg.instrumentKeys) {
                    msg.instrumentKeys.forEach(k => currentInstruments.add(k));
                }
                connectToUpstox();
            } else if (msg.type === 'subscribe') {
                if (msg.instrumentKeys) {
                    msg.instrumentKeys.forEach(k => currentInstruments.add(k));
                    console.log("Updated subscription list:", currentInstruments);
                }
            }
        } catch (e) {
            console.error("Error processing frontend message:", e);
        }
    });

    ws.on('close', () => {
        console.log("Frontend disconnected");
        frontendSocket = null;
    });
});

async function getAuthorizedUrl(token) {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: 'api.upstox.com',
            path: '/v2/feed/market-data-feed/authorize',
            method: 'GET',
            headers: {
                'Authorization': 'Bearer ' + token,
                'Accept': 'application/json'
            }
        };

        const req = https.request(options, (res) => {
            let data = '';
            res.on('data', (chunk) => data += chunk);
            res.on('end', () => {
                if (res.statusCode === 200) {
                    try {
                        const json = JSON.parse(data);
                        resolve(json.data.authorizedRedirectUri);
                    } catch (e) {
                        reject(e);
                    }
                } else {
                    reject(new Error(`API Error ${res.statusCode}: ${data}`));
                }
            });
        });

        req.on('error', (e) => reject(e));
        req.end();
    });
}

async function connectToUpstox() {
    if (upstoxSocket) {
        upstoxSocket.terminate();
    }

    try {
        console.log("Authorizing with Upstox...");
        const wsUrl = await getAuthorizedUrl(userToken);
        console.log("Authorized. Connecting to Upstox WS...");

        upstoxSocket = new WebSocket(wsUrl);
        upstoxSocket.binaryType = 'arraybuffer';

        upstoxSocket.on('open', () => {
            console.log("Connected to Upstox V3 Feed");
            // Re-init DB just in case
            initQuestDB();
        });

        upstoxSocket.on('message', (data) => {
            try {
                // Decode Protobuf
                const buffer = Buffer.from(data);
                const message = FeedResponse.decode(buffer);
                const object = FeedResponse.toObject(message, {
                    longs: String,
                    enums: String,
                    bytes: String,
                });

                // 1. Forward to Frontend (Visuals)
                if (frontendSocket && frontendSocket.readyState === WebSocket.OPEN) {
                    frontendSocket.send(JSON.stringify(object));
                }

                // 2. Persist to QuestDB (Storage)
                saveToQuestDB(object);

            } catch (e) {
                console.error("Protobuf Decode Error:", e);
            }
        });

        upstoxSocket.on('error', (err) => {
            console.error("Upstox WS Error:", err);
            if (frontendSocket) frontendSocket.send(JSON.stringify({ type: 'error', message: err.message }));
        });

        upstoxSocket.on('close', () => {
            console.log("Upstox WS Closed");
        });

    } catch (e) {
        console.error("Connection Failed:", e.message);
        if (frontendSocket) frontendSocket.send(JSON.stringify({ type: 'error', message: e.message }));
    }
}